#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import re
import sys
import getopt
import pymysql as MySQLdb
import hashlib

from agentgenerator import *
from sqlbindgenerator import *

def get_tables( results ) :
    tables = []
    for result in results :
        pos = result[0].rfind('_')
        if pos == -1 :
            tables.append( (result[0], 0) )
        else :
            tablename = result[0][:pos]
            sharding = result[0][pos+1:]
            if not sharding.isdigit() :
                tables.append( (result[0], 0) )
            else :
                for t in tables :
                    if t[0] == tablename :
                        tables.remove( t )
                        break
                tables.append( (tablename, int(sharding)+1) )
    return tables

def generate_js_version( dstpath, version ) :
    lines = []
    lines.append( 'var Version = \"%s\";\n\n' % version )
    lines.append( 'exports.Version = Version;' )
    tofile = open( '%s/Version.js' %( dstpath ), 'w' )
    for line in lines :
        tofile.write( line )
    tofile.write( '\n' )
    tofile.close()

def generate_go_version( dstpath, version ) :
    lines = []
    lines.append( '// Code generated by tool. DO NOT EDIT.\n\n' )
    lines.append( 'package main\n\n' )
    lines.append( 'const (\n' )
    lines.append( '    Version  string = `%s`\n' % version )
    lines.append( ')\n' )
    tofile = open( '%s/scheme/version.go' %( dstpath ), 'w' )
    for line in lines :
        tofile.write( line )
    tofile.write( '\n' )
    tofile.close()

def generate_go_plugin( tables, dstpath, version ) :
    lines = []
    lines.append( '// Code generated by tool. DO NOT EDIT.\n\n' )
    lines.append( 'package main\n\n' )
    lines.append( 'import (\n' )
    lines.append( '    \"reflect\"\n' )
    lines.append( '    \"strings\"\n' )
    for tbl in tables :
        table = MySQLTable( tbl[0], tbl[1] )
        lines.append( '    \"scheme/%s\"\n' % table.tablename().lower() )
    lines.append( ')\n\n' )
    lines.append( 'func New( name string) interface{} {\n' )
    lines.append( '    var v interface{}\n' )
    lines.append( '    switch name {\n' )
    for tbl in tables :
        table = MySQLTable( tbl[0], tbl[1] )
        lines.append( '        case \"%s\":\n' % table.tablename() )
        lines.append( '            v = &%s.%s{}\n' % ( table.tablename().lower(), table.tablename() ) )
    lines.append( '    }\n' )
    lines.append( '    return v\n' )
    lines.append( '}\n\n' )
    lines.append( 'func Get(info interface{}, name string) interface{} {\n' )
    lines.append( '    return reflect.ValueOf(info).MethodByName(\"Get\" + name).Call([]reflect.Value{})[0]\n' )
    lines.append( '}\n\n' )
    lines.append( 'func Set(info interface{}, m map[string]interface{}) {\n' )
    lines.append( '    ref := reflect.ValueOf(info)\n' )
    lines.append( '    for k, v := range m {\n' )
    lines.append( '        // 值类型\n' )
    lines.append( '        t := reflect.TypeOf(v)\n' )
    lines.append( '        // 方法名\n' )
    lines.append( '        fc := \"Set\" + strings.ToUpper(k[:1]) + k[1:]\n' )
    lines.append( '        // 调用方法\n' )
    lines.append( '        setMethod := ref.MethodByName(fc)\n' )
    lines.append( '        // 参数类型\n' )
    lines.append( '        fcArg := setMethod.Type().In(0)\n' )
    lines.append( '        // 目前接收到的值只有float64和string\n' )
    lines.append( '        if t.Name() != fcArg.Name() {\n' )
    lines.append( '            // v为float64的情况,转为方法需要的类型\n' )
    lines.append( '            switch fcArg.Name() {\n' )
    lines.append( '            case \"uint64\":\n' )
    lines.append( '                value := uint64(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            case \"uint16\":\n' )
    lines.append( '                value := uint16(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            case \"uint32\":\n' )
    lines.append( '                value := uint32(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            case \"int64\":\n' )
    lines.append( '                value := int64(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            case \"int16\":\n' )
    lines.append( '                value := int16(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            case \"int32\":\n' )
    lines.append( '                value := int32(v.(float64))\n' )
    lines.append( '                args := []reflect.Value{reflect.ValueOf(value)}\n' )
    lines.append( '                setMethod.Call(args)\n' )
    lines.append( '            }\n' )
    lines.append( '        } else {\n' )
    lines.append( '            // v为string的情况\n' )
    lines.append( '            args := []reflect.Value{reflect.ValueOf(v)}\n' )
    lines.append( '            setMethod.Call(args)\n' )
    lines.append( '        }\n' )
    lines.append( '    }\n' )
    lines.append( '}\n' )
    tofile = open( '%s/scheme/plugin.go' %( dstpath ), 'w' )
    for line in lines :
        tofile.write( line )
    tofile.write( '\n' )
    tofile.close()

def scan_database( language, dstpath ) :
    tablestatus = {}
    conn = MySQLdb.connect( host=HOST, user=USERNAME, passwd=PASSWORD, db=DATABASE, port=PORT )
    handler = conn.cursor()
    handler.execute( 'show tables' )
    # 处理分表的逻辑
    tables = get_tables( handler.fetchall() )
    # 处理目录
    if language == '--js_out' :
        agent_dstpath = dstpath
        generate_js_version( agent_dstpath, SCHEMEVERSION )
    elif language == '--go_out' :
        agent_dstpath = dstpath
        generate_go_version( agent_dstpath, SCHEMEVERSION )
        generate_go_plugin( tables, agent_dstpath, SCHEMEVERSION )
    else :
        agent_dstpath = '%s/src/thirdparty/scheme' % dstpath
    print( 'Generate Agent Code(s) ON %s to %s ...' % ( DATABASE, agent_dstpath ) )
    # 逐个生成代码
    for tbl in tables :
        print( '-- Bind %s::Table : %s(%d)' % ( DATABASE, tbl[0], tbl[1] ) )
        table = MySQLTable( tbl[0], tbl[1] )
        # 获取表结构
        s = table.loads( handler )
        tablestatus[ tbl[0] ] = s
        # 生成agent
        SqlGenerator( table ).generate( language, agent_dstpath, SCHEMEVERSION )
    if language == '--cpp_out' :
        SqlbindGenerator( tables ).generate( agent_dstpath, tablestatus, SCHEMEVERSION )
    elif language == '--go_out' :
        do_zipcompress( dstpath, SCHEMEVERSION )
    handler.close()
    conn.close()
    print( 'Generate Agent Code(s) ON %s to %s succeed .' % ( DATABASE, agent_dstpath ) )

def help() :
    print( 'sqlbind.py [-i|-p|-u|-P|-d|-s] [-h] --cpp_out=path : Generate C++ Code' )
    print( 'sqlbind.py [-i|-p|-u|-P|-d|-s] [-h] --js_out=path : Generate JS Code' )
    print( 'sqlbind.py [-i|-p|-u|-P|-d|-s] [-h] --go_out=path : Generate Go Code' )

def md5sum( path ) :
    if not os.path.isfile( path ) :
        return ""
    myhash = hashlib.md5()
    f = open( path, 'rb' )
    while True :
        b = f.read( 8096 )
        if not b :
            break
        myhash.update( b )
    f.close()
    return myhash.hexdigest()

def do_zipcompress( dstpath, version ) :
    zipname = '%s/%s.tgz' % ( dstpath, version )
    #print( 'do_zipcompress path:%s' % dstpath )
    os.system( 'tar -C %s -zcf %s scheme' % ( dstpath, zipname ) )

def parse_args() :
    global HOST
    global PORT
    global USERNAME
    global PASSWORD
    global DATABASE
    global SCHEMEVERSION
    try:
        options,args = getopt.getopt( sys.argv[1:],
                "hi:p:u:P:d:s:",
                ["help", "ip=", "port=", "username=", "password=", "database=", "signature=", "cpp_out=", "js_out=", "go_out="] )
    except getopt.GetoptError :
        sys.exit()
    for name,value in options :
        if name in ( "-h", "--help" ) :
            help()
        if name in ( "-i", "--ip" ) :
            HOST=value
        if name in ( "-p", "--port" ) :
            PORT=int(value)
        if name in ( "-u", "--username" ) :
            USERNAME = value
        if name in ( "-P", "--password" ) :
            PASSWORD = value
        if name in ( "-d", "--database" ) :
            DATABASE = value
        if name in ( "-s", "--signature" ) :
            SCHEMEVERSION=md5sum( value )
        if name == "--cpp_out" :
            path = value
            language = name
        elif name == "--js_out" :
            path = value
            language = name
        elif name == "--go_out" :
            path = value
            language = name
    return path, language

if __name__ == "__main__" :
    path, language = parse_args()
    scan_database( language, path )
